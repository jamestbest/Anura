// pages
//  2916- opcode map (1 byte)
//  2910- opcode map key
//  527 - SIB information
//  2949- instr encoding
//  1257- MOV encoding
//  529 - REX prefix encoding
//  87  - SIB information (limited)
//  765 - CMOVcc encoding
//  521 - Instruction encoding
//  535 - VEX prefix encoding
//  558 - EVEX prefix encoding

// RULE ON NUMBERS
//  some places expect base 10, i.e. anywhere that isn't inside {} e.g. 4 bits
//  most places expect base 2 written as 0011 1011
//  numbers are written from high bit - low bit and will go until 8 bits are found
//  e.g. 1010 101 ow -- this is one byte as any non-alias identifier is 1 bit in size
//  e.g. 10 reg 001  -- this is one byte (assuming reg is a 3 bit ALIAS)

ALIAS prefix= {
    REX
    VEX
    EVEX
}

STRUCTURE
lprefix* prefix? op 

// assume we're in long mode
//  so assume REX exists -- I don't want to do include protected mode
//   with stuff like single byte inc, just keep to long mode
//  SO is this --v needed?? -- I assume not
FLAG mode= 64bit | 32bit | 16bit default 64bit
FLAG opmode= 64bit | 32bit | 16bit | 8bit default 32bit
FLAG ow

// REX.W is for OPERAND size
// REX.W = 64 Bit Operand Size
// REX.R is for Rrrr
// REX.R = Extension of the ModR/M reg field
// REX.X is for X(SIB.xxx)
// REX.X = Extension of the SIB index field
// REX.B is for B(SIB.bbb)
//       or for Brrr
//       or for B(RM.bbb)
// REX.B = Extension of the ModR/M r/m field, SIB base field, or Opcode reg field
ALIAS REX 1 byte= {
  0100 rexw rexr rexx rexb
}

// these bits have been writted in the high-low level, is this ok to assume?
//  when reading new bytes we just read high bit as we get the whole byte at once
// dot prefix? for accessing values within? or the alias listing?
ALIAS VEX 1 byte= {
  1100 0100 .R .X .B .m(5) .W .v(4) .L .pp(2)
  1100 0101 .R .v(4) .L .pp(2)
}

ALIAS lprefix= {
  lp1
  lp2
  lp3
  lp4
}

ALIAS lp1= {
  LOCK= 0xF0
  REPNE,REPNZ,BND= 0xF2  // BND has some restrictions to do with what the instr is
  REP,REPE,REPZ= 0xF3
}

ALIAS lp2= {
  CS,BNT= 0x2E
  SS= 0x36
  DS,BT = 0x3E
  ES= 0x26
  FS= 0x64
  GS= 0x65
}

ALIAS lp3= {
  OO= 0x66
}

ALIAS lp4= {
  AO= 0x67
}

ALIAS reg 3 bits= {
  AX, AL, AL, EAX, RAX= 000
  CX, CL, AL, ECX, RCX= 001
  
  SP, AH, AL, ESP, RSP= 100
}

RULE ON reg {
  CHOOSE 0 if opmode= 16bit
  CHOOSE 1 if ow == 0 and rexw != 1
  CHOOSE 2 if ow == 0
  CHOOSE 3 if opmode= 32bit
  CHOOSE 4 if opmode= 64bit
}

ALIAS cc 4 bits= {
  O= 0000
  NO= 0001
  B,C,NAE= 0010
  NB,NC,AE= 0011
  E,Z= 0100
  NE,NZ=0101
  BE,NA=0110
  NBE,A=0111
  S=1000
  NS=1001
  P,PE=1010
  NP,PO=1011
  L,NGE=1100
  NL,GE=1101
  LE,NG=1110
  NLE,G=1111
}

ALIAS Mod 2 bits= {}
ALIAS RM 3 bits= {}
ALIAS sibs 2 bits= {}
ALIAS sibi 3 bits= reg
ALIAS sibb 3 bits= reg
ALIAS SIB 8 bits= {
  sibs 100 sibb = 
  sibs sibi 101 = {
    if Mod == 00 then [sibi * (2 ^ sibs)] + disp32
    if Mod == 01 then [sibi * (2 ^ sibs)] + disp8 + [EBP]
    if Mod == 10 then [sibi * (2 ^ sibs)] + disp32 + [EBP]
  }
  sibs sibi sibb = [sibi * (2 ^ sibs)] + sibb
}

ALIAS ModRM= {
  Mod reg RM
}

RULE ON ModRM {
  if opmode != 16bit && Mod != 0b11 && RM == 0b100 then EXPECT SIB
}

ALIAS op= {
  0x0f op2
  MOV
  CMOV
}

ALIAS op2= {
  CVTDQ2PD xyzreg, xyzrm= E6 ModRM REQUIRE REP // change on E/VEX
  ENDBR64= 1E FA REQUIRE REP
}

CALCULATE opmode= {
  if mode == 32bit && lp3 then 16bit
  if mode == 16bit && lp3 then 32bit
  if mode == 32bit then 32bit
  if mode == 16bit then 16bit

  if rexw then 64bit
  if lp3 then 16bit
  if default then 32bit
}

ALIAS imm x bits= {
  if opmode == 8bit then 8 bits
  if opmode == 16bit then 16 bits
  if opmode == 32bit then 32 bits
  if opmode == 64bit then 64 bits
}

ALIAS RM 3 bits= {
  if Mod == 00 then {
     101= EXPECT disp32
     default= EXPECT SIB
  }
  if Mod == 01 then EXPECT SIB
  if Mod == 10 then EXPECT SIB
  if Mod == 11 then reg
}

// opcodes are matched up to the next non-0|1
//  i.e. each level is expanded to it's level of 1|0s
//  and each is an opcode

ALIAS MOV= {
  TRANSLATE reg {
    AH= SPL
    BH= DIL
    CH= BPL
    DH= SIL
  }

  1000 100 ow ModRM= MOV RM, reg
  1000 101 ow ModRM= MOV reg, RM
  1100 011 ow Mod 000 RM imm = MOV RM, imm
 
  1011 ow reg imm= MOV reg, imm
}


CMOV|cc reg, RM = 0F 0x40+cc ModRM

ALIAS ADC= {
  0b0000111 ow imm[8,16,32]= ADC reg, imm[8,16,32]
  0b1000000 ow
  ADC AL, imm8= 0x14 imm8

}
