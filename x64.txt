// pages
//  2916- opcode map (1 byte)
//  2910- opcode map key
//  527 - SIB information
//  2949- instr encoding
//  1257- MOV encoding
//  529 - REX prefix encoding
//  87  - SIB information (limited)
//  765 - CMOVcc encoding
//  521 - Instruction encoding
//  535 - VEX prefix encoding
//  558 - EVEX prefix encoding

// RULE ON NUMBERS
//  some places expect base 10, i.e. anywhere that isn't inside {} e.g. 4 bits
//  most places expect base 2 written as 0011 1011
//  numbers are written from high bit - low bit and will go until 8 bits are found
//  e.g. 1010 101 ow -- this is one byte as any non-alias identifier is 1 bit in size
//  e.g. 10 reg 001  -- this is one byte (assuming reg is a 3 bit ALIAS)

ALIAS prefix= {
    REX
    VEX
    EVEX
}

STRUCTURE lprefix* prefix? op

// assume we're in long mode
//  so assume REX exists -- I don't want to do include protected mode
//   with stuff like single byte inc, just keep to long mode
//  SO is this --v needed?? -- I assume not
FLAG mode= 64bit | 32bit | 16bit default 64bit
FLAG opmode= 64bit | 32bit | 16bit | 8bit default 32bit
FLAG ow

// REX.W is for OPERAND size
// REX.W = 64 Bit Operand Size
// REX.R is for Rrrr
// REX.R = Extension of the ModR/M reg field
// REX.X is for X(SIB.xxx)
// REX.X = Extension of the SIB index field
// REX.B is for B(SIB.bbb)
//       or for Brrr
//       or for B(RM.bbb)
// REX.B = Extension of the ModR/M r/m field, SIB base field, or Opcode reg field
ALIAS REX 1 byte= {
  0100 .w .r .x .b
}

// these bits have been writted in the high-low level, is this ok to assume?
//  when reading new bytes we just read high bit as we get the whole byte at once
// dot prefix? for accessing values within? or the alias listing?
ALIAS VEX 1 byte= {
  1100 0100 .R .X .B .m(5) .W .v(4) .L .pp(2)
  1100 0101 .R .v(4) .L .pp(2)
}

ALIAS lprefix 1 byte= {
  lp1
  lp2
  lp3
  lp4
}

ALIAS lp1 1 byte= {
  0xF0= LOCK
  0xF2= REPNE,REPNZ,BND  // BND has some restrictions to do with what the instr is
  0xF3= REP,REPE,REPZ
}

ALIAS lp2 1 byte= {
  0x2E= CS,BNT
  0x36= SS
  0x3E= DS,BT
  0x26= ES
  0x64= FS
  0x65= GS
}

ALIAS lp3 1 byte= {
  0x66= OO
}

ALIAS lp4 1 byte= {
  0x67= AO
}

ALIAS reg 3 bits= {
  000= AX, AL, AL, EAX, RAX
  001= CX, CL, AL, ECX, RCX
  
  100= SP, AH, AL, ESP, RSP
}

// some instructions access SPL etc. instead of AH etc.
ALIAS regT 3 bits= {
  000= AX, AL, AL, EAX, RAX
  001= CX, CL, AL, ECX, RCX

  100= SP, SPL, AL, ESP, RSP
}

RULE RIGHT ON reg, regT {
  CHOOSE 0 if opmode= 16bit
  CHOOSE 1 if ow == 0 and REX.w != 1
  CHOOSE 2 if ow == 0
  CHOOSE 3 if opmode= 32bit
  CHOOSE 4 if opmode= 64bit
}

ALIAS cc 4 bits= {
  0000= O
  0001= NO
  0010= B,C,NAE
  0011= NB,NC,AE
  0100= E,Z
  0101= NE,NZ
  0110= BE,NA
  0111= NBE,A
  1000= S
  1001= NS
  1010= P,PE
  1011= NP,PO
  1100= L,NGE
  1101= NL,GE
  1110= LE,NG
  1111= NLE,G
}

ALIAS sibs 2 bits
ALIAS sibi= reg
ALIAS sibb= reg

ALIAS sibsi 5 bits= {
   sibs 100 =
   sibs sibi= [sibi * (2 ^ sibs)]
}

ALIAS SIB 1 byte= {
  sibsi 101 = {
    if Mod == 00 then sibsi + disp32
    if Mod == 01 then sibsi + disp8 + [EBP]
    if Mod == 10 then sibsi + disp32 + [EBP]
  }
  sibsi sibb = sibsi + sibb
}

ALIAS Mod 2 bits= {}
ALIAS RM 3 bits
ALIAS ModRM= {
  11 reg 100 SIB= SIB
  00 reg 101 disp32= {
    when mode == 64bit then "rip" + disp32
    when default then disp32
  }
  00 reg RM= [reg]
  01 reg RM disp8 = [reg] + disp8
  10 reg RM disp32= [reg] + disp32
  11 reg RM= reg
}

ALIAS op= {
  0x0f op2
  MOV
  ADC
}

ALIAS op2= {
  0xE6 ModRM REQUIRE REP= CVTDQ2PD xyzreg, xyzrm=  // change on E/VEX
  0x1E 0xFA  REQUIRE REP= ENDBR64
  CMOV
}

CALCULATE opmode= {
  when mode == 32bit then {
    if lp3 then 16bit
    if default then 32bit
  }
  when mode == 16bit then {
    if lp3 then 32bit
    if default then 16bit
  }

  if REX.w then 64bit
  if lp3 then 16bit
  if default then 32bit
}

DATA imm x bits= {
  if opmode == 8bit then 1 byte
  if opmode == 16bit then 2 bytes
  if opmode == 32bit then 4 bytes
  if opmode == 64bit then 8 bytes
}

DATA immM32 x bits= {
  if opmode == 8bit then 1 byte
  if opmode == 16bit then 2 bytes
  if opmode == 32bit then 4 bytes
  if opmode == 64bit then 4 bytes
}

DATA disp8 1 byte
DATA disp16 2 bytes
DATA disp32 4 bytes

// opcodes are matched up to the next non-0|1
//  i.e. each level is expanded to it's level of 1|0s
//  and each is an opcode

ALIAS MOV= {
  1000 100 ow ModRM= MOV RM, regT
  1000 101 ow ModRM= MOV regT, RM
  1100 011 ow Mod 000 RM imm = MOV RM, imm
 
  1011 ow reg imm= MOV regT, imm
}

ALIAS regA= reg AS 000

ALIAS ADC= {
  0000 111 ow immM32= ADC regA, immM32
  1000 000 ow immM32= ADC reg, immM32
  1000 0011 mod 010 reg imm8= ADC reg, imm8
  0001 000 ow ModRM = ADC rm, reg
  0001 001 ow ModRM = ADC reg, rm
}

ALIAS CMOV= {
  0100 cc ModRM = CMOV|cc reg, rm
}

if vs when semantic for something that can back when assemble
vs something that is based on a mode set at the start









// example of ARM64 adc
ALIAS S 1 bit= {
  0=""
  1="S"
}
ALIAS regA 5 bits= {
  00000= W0, X0
  00001= W1, X1
  11110= W30, X30
}
RULE RIGHT ON regA {
  CHOOSE 0 if sf == 0
  CHOOSE 1 if sf == 1
}
ALIAS rd= regA
ALIAS AADC= {
  sf S 01 1010 000 rm 0000 00 rn rd= ADC|S rd, rn, rm
}
